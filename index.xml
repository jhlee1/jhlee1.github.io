<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Code Repository</title>
    <link>https://jhlee1.github.io/</link>
    <description>Recent content on Code Repository</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 07 May 2019 23:35:35 +0900</lastBuildDate>
    
        <atom:link href="https://jhlee1.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Object literal and this</title>
      <link>https://jhlee1.github.io/2019/javascriptobjectliteral/</link>
      <pubDate>Tue, 07 May 2019 23:35:35 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/javascriptobjectliteral/</guid>
      <description>Object Literal과 this 1. 자바스크립트 객체의 활용  객체 리터럴 예제  var healthObj = { name : &amp;quot;달리기&amp;quot;, lastTime : &amp;quot;PM10:12&amp;quot;, showHealth : function() { console.log(this.name + &amp;quot;님, 오늘은 &amp;quot; + this.lastTime + &amp;quot;에 운동을 하셨네요&amp;quot;); // this는 이 함수가 불리는 Context를 가르킴. healthObj를 this로 접근 } } healthObj.showHealth();  ### 2. this
 객체 안에서의 this는 그 객체 자신 ES6에서는 객체에서 메서드를 사용할 때 &amp;lsquo;function&amp;rsquo; 키워드를 생략할 수 있다.</description>
    </item>
    
    <item>
      <title>Javascript Functional Method in Array</title>
      <link>https://jhlee1.github.io/2019/javascriptarrayfunctionalmethod/</link>
      <pubDate>Tue, 07 May 2019 22:42:05 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/javascriptarrayfunctionalmethod/</guid>
      <description>배열의 함수형 메소드 1. for vs. forEach  기본 data set  var data = [ {title: &amp;quot;Hello1&amp;quot;, content: &amp;quot;random content1&amp;quot;, price: 12000}, {title: &amp;quot;Hello2&amp;quot;, content: &amp;quot;random content2&amp;quot;, price: 5500}, {title: &amp;quot;Hello3&amp;quot;, content: &amp;quot;random content3&amp;quot;, price: 1200} ];   for 사용  for (var i = 0; i &amp;lt; data.length; i++) { console.log(data[i].title, data[i].price); }   forEach 사용 (함수형 Method 이용)  data.forEach(function(v) { console.log(v.title, v.price); });  &amp;lt;=&amp;gt;</description>
    </item>
    
    <item>
      <title>RestController</title>
      <link>https://jhlee1.github.io/2019/restcontroller/</link>
      <pubDate>Mon, 06 May 2019 23:23:40 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/restcontroller/</guid>
      <description>RestController 1. @RestController  Spring 4에서 RestAPI 또는 Web API를 개발하기 위해 등장 이전 버전의 @Controller와 @ResponseBody를 포함 Rest API를 구현하기 위해 MessageConverter가 중요함  2. MessageConvertor  자바 객체와 HTTP 요청 / 응답 바디를 변환하는 역할 (주로 Json) @ResponseBody, @RequestBody @EnableWebMvc 로 인한 기본 설정 WebMvcConfigurationSupport 를 사용하여 Spring MVC 구현 Default MessageConvertor 를 제공  3. JSON 응답하기  Controller의 메소드에서는 JSON으로 변환될 객체를 반환 @EnableWebMvc에서 jackson library를 기본 설정으로 사용함 jackson라이브러리를 추가하지 않으면 JSON메시지로 변환할 수 없어 500 Error 발생 사용자가 임의의 메시지 컨버터(MessageConverter)를 사용하도록 하려면 WebMvcConfigurerAdapter의 configureMessageConverters메소드를 @Override해야함  ex) GuestbookAPIController.</description>
    </item>
    
    <item>
      <title>LayeredArchitecture</title>
      <link>https://jhlee1.github.io/2019/layeredarchitecture/</link>
      <pubDate>Sun, 05 May 2019 23:10:36 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/layeredarchitecture/</guid>
      <description>Layered Architecture 1. Controller에서 중복되는 부분을 처리하려면?  별도의 객체로 분리 별도의 Method로 분리 쇼핑몰에서 게시판에서도 회원정보를 보여주고, 상품 목록 보기에서도 회원정보를 보여주는 경우 회원 정보를 읽어오는 코드는 어떻게 해야 할까?  2. Controller와 Service  비지니스 로직을 별도의 Service 객체를 구현하도록 하고 Controller는 Service 객체를 사용 Service 객체란  Business Logic을 수행하는 Method를 가지고 있는 객체 하나의 Business Logic은 하나의 Transaction으로 동작   3. Transaction  하나의 논리적인 작업을 의미</description>
    </item>
    
    <item>
      <title>LayeredArchitectureImplementation</title>
      <link>https://jhlee1.github.io/2019/layeredarchitectureimplementation/</link>
      <pubDate>Sun, 05 May 2019 18:01:53 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/layeredarchitectureimplementation/</guid>
      <description>Layered Architecture 실습 1. 방명록 만들기  Spring JDBC를 이용한 DAO 작성 Controller + Service + Dao Transaction 처리 Spring MVC에서 form 값 입력받기 Spring MVC에서 redirect하기 Controller에서 jsp에게 전달한 값을 JSTL과 EL을 이용해 출력하기 설정파일  Web Layer 설정 파일: web.xml, WebMvcContextConfiguration.java Business, Repository Layer 설정 파일: ApplicationConfig.java, DbConfig.java   2. 요구 사항  방명록 정보는 guestbook Table에 저장  id는 자동 입력 id, 이름, 내용, 등록일을 저장  http://localhost:8080/guestbook/을 요청하면 자동으로 /guestbook/list로 redirect  방명록이 없으면 건수는 0이 나오고 아래에 방명록을 입력하는 form이 보여진다.</description>
    </item>
    
    <item>
      <title>Spring MVC Implementation</title>
      <link>https://jhlee1.github.io/2019/springmvcimplementation/</link>
      <pubDate>Sun, 05 May 2019 06:59:02 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/springmvcimplementation/</guid>
      <description>Spring MVC 실습 1. Controller 작성 실습  브라우저에서 http://localhost:8080/mvcexam/plusform이라고 요청을 보내면 서버는 2개의 값을 입력받을 수 있는 입력 창과 버튼이 있는 화면을 보여줌 2개의 값을 입력하고 버튼을 클릭하면 POST http://localhost:8080/mvcexam/plus로 2개의 입력값이 전달됨. 서버는 두 값을 더한 후 jsp에게 request scope로 전달하여 출력  2. 프로젝트 세팅  maven 프로젝트에서 archetype을 webapp으로 생성 pom.xml 설정
 Dependency와 Plugin에 Maven compiler, JSTL, Servlet JSP, Spring 관련 설정들을 넣어준다.
&amp;lt;properties&amp;gt; &amp;lt;project.</description>
    </item>
    
    <item>
      <title>Spring MVC</title>
      <link>https://jhlee1.github.io/2019/springmvc/</link>
      <pubDate>Mon, 29 Apr 2019 12:43:40 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/springmvc/</guid>
      <description>Spring MVC 1. MVC?  Model-View-Controller의 약자 제록스 연구소에서 일하던 린즈커그가 처음 소개한 개념으로, Desktop Application용으로 고안됨 Model: View가 렌더링하는데 필요한 Data  ex) 사용자가 요청한 상품 목록, 주문 내역  View: 실제 보이는 부분, Model을 사용하여 렌더링 한다.  ex) jsp, jsf, pdf, xml등으로 결과를 표현  Controller: 사용자의 액션에 응답하는 Componennt. Controller는 Model을 업데이트하고 다른 액션을 수행  2. Model 1 방식  Jsp에 HTML과 Java코드가 섞여서 복잡해짐  3.</description>
    </item>
    
    <item>
      <title>Spring JDBC Implementation</title>
      <link>https://jhlee1.github.io/2019/springjdbcimplementation/</link>
      <pubDate>Thu, 25 Apr 2019 12:43:40 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/springjdbcimplementation/</guid>
      <description>Spring JDBC 구현하기 1. DTO (Data Transfer Object)  계층간의 데이터 교환을 위한 Bean이다 계층 - Controller View, Business Layer, Persistence Layer를 의미 일반적으로 DTO는 로직을 갖고 있지 않고 순수한 Data 객체  2. DTO의 예  field, getter, setter를 가진다. 추가적으로, toString(), equals(), hashCode() 등의 Object가 가진 method를 @Override할 수 있다.  public class ActorDTO { private Long id; private String firstName; private String lastName; public String getFirstName() { return this.</description>
    </item>
    
    <item>
      <title>Binary Search</title>
      <link>https://jhlee1.github.io/2019/binarysearch/</link>
      <pubDate>Wed, 24 Apr 2019 13:09:29 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/binarysearch/</guid>
      <description>Binary Search  Recursive  public class Solution { public static boolean binarySearchRecursive(int[] array, int x, int left, int right) { if (left &amp;gt; right) { return false; } int mid = left + ((right - left) / 2); // To avoid integer overflow used instead of (left + right) / 2 if(array[mid] == x) { return true; } else if (x &amp;lt; array[mid]) { return binarySearchRecursive(array, x, left, mid - 1); } else { return binarySearchRecursive(array, x, mid + 1, right); } } public static boolean binarySaerchRecursive(int[] array, int x) { return binarySaerchRecursive(array, x, 0, array.</description>
    </item>
    
    <item>
      <title>Bubble Sort</title>
      <link>https://jhlee1.github.io/2019/bubblesort/</link>
      <pubDate>Mon, 22 Apr 2019 13:09:29 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/bubblesort/</guid>
      <description> Bubble Sort public class Solution { public static void bubblesort(int[] array) { boolean isSorted = false; int lastUnsorted = array.length - 1; while (!isSorted) { isSorted = true; for(int i = 0; i &amp;lt; lastUnsorted; i++) { if(array[i] &amp;gt; array[i+1]) { int tmp = array[i]; array[i] = array[i+1]; array[i+1] = tmp; lastSorted = false; } } lastUnsorted--; } } }  </description>
    </item>
    
    <item>
      <title>Spring JDBC</title>
      <link>https://jhlee1.github.io/2019/springjdbc/</link>
      <pubDate>Mon, 22 Apr 2019 12:43:40 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/springjdbc/</guid>
      <description>Spring JDBC 1. 개념  JDBC를 이용한 개발에서 반복적으로 등장하는 저수준 세부사항을 처리해준다 개발자는 필요한 부분만 개발     Action Spring Developer     Connection parameter 정의  O   Connection 오픈 O    SQL query  O   Parameter 선언과 Parameter Value 제공  O   Statement 준비와 실행 O    (존재한다면) 결과를 반복하는 Loop 설정 O    각 Iteration에 대한 작업 수행  O   Exception Handling - Spring에서 제공하는 Exception으로 변환 O    Connection, Statement, ResultSet 닫기 O     2.</description>
    </item>
    
    <item>
      <title>HTMLTemplating</title>
      <link>https://jhlee1.github.io/2019/htmltemplating/</link>
      <pubDate>Thu, 18 Apr 2019 00:43:40 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/htmltemplating/</guid>
      <description>HTML Templating 1. 개념  반복적인 HTML부분을 template로 만들어두고, 서버에서 온 데이터(주로JSON)을 결합해서, 화면에 추가하거나 삭제하는 작업 JSON 형태의 데이터를 받을 것이고요.  2. HTML과 JSON 결합 예제  HTML 코드  &amp;lt;li&amp;gt; &amp;lt;h4&amp;gt;{title}&amp;lt;/h4&amp;gt; &amp;lt;p&amp;gt;{content}&amp;lt;/p&amp;gt; &amp;lt;div&amp;gt;{price}&amp;lt;/div&amp;gt; &amp;lt;/li&amp;gt;   JSON Data  { title: &amp;quot;Test Product&amp;quot;, content: &amp;quot;This is a description&amp;quot;, price: 2000 }   결합된 HTML  &amp;lt;li&amp;gt; &amp;lt;h4&amp;gt;Test Product&amp;lt;/h4&amp;gt; &amp;lt;p&amp;gt;This is a description&amp;lt;/p&amp;gt; &amp;lt;div&amp;gt;2000&amp;lt;/div&amp;gt; &amp;lt;/li&amp;gt;   Console에서 실행해보기  var data = { title: &amp;quot;Test Product&amp;quot;, content: &amp;quot;This is a description&amp;quot;, price: 2000 }; var html = &amp;quot;&amp;lt;li&amp;gt;&amp;lt;h4&amp;gt;{title}&amp;lt;/h4&amp;gt;&amp;lt;p&amp;gt;{content}&amp;lt;/p&amp;gt;&amp;lt;div&amp;gt;{price}&amp;lt;/div&amp;gt;&amp;lt;/li&amp;gt;&amp;quot;; var resultHTML = html.</description>
    </item>
    
    <item>
      <title>JavascriptEventDelegation</title>
      <link>https://jhlee1.github.io/2019/javascripteventdelegation/</link>
      <pubDate>Tue, 16 Apr 2019 13:28:33 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/javascripteventdelegation/</guid>
      <description>Javascript Event Delegation 1. 각각의 li 마다 event listener를 등록  main.html  &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;link rel=&amp;quot;stylesheet&amp;quot; href=&amp;quot;./css/main.css&amp;quot;&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt; &amp;lt;img src=&amp;quot;https://images-na.,,,,,/513hgbYgL._AC_SY400_.jpg&amp;quot; class=&amp;quot;product-image&amp;quot; &amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; &amp;lt;img src=&amp;quot;https://images-n,,,,,/41HoczB2L._AC_SY400_.jpg&amp;quot; class=&amp;quot;product-image&amp;quot; &amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; &amp;lt;img src=&amp;quot;https://images-na.,,,,51AEisFiL._AC_SY400_.jpg&amp;quot; class=&amp;quot;product-image&amp;quot; &amp;gt; &amp;lt;/li&amp;gt; &amp;lt;li&amp;gt; &amp;lt;img src=&amp;quot;https://images-na,,,,/51JVpV3ZL._AC_SY400_.jpg&amp;quot; class=&amp;quot;product-image&amp;quot; &amp;gt; &amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;section class=&amp;quot;log&amp;quot;&amp;gt;&amp;lt;/section&amp;gt; &amp;lt;script src=&amp;quot;js/main.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/html&amp;gt;   main.js  var log = document.querySelector(&amp;quot;.log&amp;quot;); var lists = document.querySelector(&amp;quot;ul &amp;gt; li&amp;quot;); for (var i = 0; len = lists.</description>
    </item>
    
    <item>
      <title>Javascript DOM ContentLoaded Event</title>
      <link>https://jhlee1.github.io/2019/javascriptload/</link>
      <pubDate>Tue, 16 Apr 2019 13:25:24 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/javascriptload/</guid>
      <description>DOM ContentLoaded Event 와 Window.load의 차이 1. DOM Content Loaded와 load의 차이  크롬 개발자도구의 Network panel을 열어서 왼쪽 아래에 DOMContentLoaded, load를 확인 DOM Tree 분석이 끝나면 DOMContentLoaded 이벤트가 발생하며, 그 외 모든 자원이 다 받아져서 브라우저에 렌더링(화면 표시)까지 다 끝난 시점에는 Load가 발생 보통 DOM tree가 다 만들어지면 DOM APIs를 통해서 DOM에 접근할 수 있기 때문에, 실제로 실무에서는 대부분의 자바스크립트코드는 DOMContentLoaded 이후에 동작하도록 구현하기 때문에 load는 거의 쓰이지 않음  //DOM Content Loaded Event 추가 document.</description>
    </item>
    
    <item>
      <title>JavascriptAnimation</title>
      <link>https://jhlee1.github.io/2019/javascriptanimation/</link>
      <pubDate>Sat, 13 Apr 2019 01:25:24 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/javascriptanimation/</guid>
      <description>Animation과 SetTimeout의 이해 1. Animation  반복적인 움직임의 처리 Web UI의 animation은 Javascript로 다양하게 처리할 수 있지만, 규칙적이고 단순한 방식으로 동작되는 것은 CSS3의 transition과 transform 속성을 이용하여 구현 가능 CSS를 사용하는 것이 Javascript 보다 더 빠른 성능을 보여줌 특히, 모바일 웹에선 CSS를 사용하는 것이 훨씬 더 빠름 간단하고 규칙적이다 -&amp;gt; CSS로 구현 세밀하고 조작이 필요하다 -&amp;gt; JS로 구현 성능만 봐서는 대체로 CSS가 빠르나 성능 비교를 통해서 가장 빠른 방법을 찾는 과정이 필요  2.</description>
    </item>
    
    <item>
      <title>JavascriptAsync</title>
      <link>https://jhlee1.github.io/2019/javascriptasync/</link>
      <pubDate>Fri, 12 Apr 2019 17:08:52 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/javascriptasync/</guid>
      <description>1. AJAX와 비동기 function ajax() { var oReq = new XMLHttpRequest(); oReq.addEventListener(&amp;quot;load&amp;quot;, function() { //밑에 oReq.open과 oReq.send보다 더 늦게 실행됨. console.log(this.responseText); }); oReq.open(&amp;quot;GET&amp;quot;, &amp;quot;http://www.example.org/example/txt&amp;quot;); oReq.send(); }   비동기로 실행되는 EventListener속에 있는 anonymous 함수는 브라우저가 가지고 있는 Web Apis와 Callback Queue(=task queue)를 거쳐서 다시 Call Stack으로 들어가기 때문에 가장 나중에 실행됨.(Call stack -&amp;gt; Web Apis -&amp;gt; Callback Queue -&amp;gt; Call stack이 비어있는지 확인 후 Call Stack으로 이동 후 -&amp;gt; execute의 단계를 거침)</description>
    </item>
    
    <item>
      <title>DOM APIs</title>
      <link>https://jhlee1.github.io/2019/dom_apis/</link>
      <pubDate>Fri, 12 Apr 2019 10:53:30 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/dom_apis/</guid>
      <description>DOM API 활용 1. 다양한 APIs  document. 관련API element. 관련 API  2. DOM 엘리먼트 오브젝트  tagName : Element의 tag name textContent : Node의 text content를 설정하거나 얻어옴 nodeType : Node type을 숫자로 나타냄 childNodes: Element의 Childs를 Node List로 나타냄 (Text node, Comment node 포함)  ex) ```javascript Javascipt 코드 var ul = document.querySelector(&amp;ldquo;ul&amp;rdquo;); var ulChildNodes = ul.childNodes   for (var index = 0; index &amp;lt; ulChildNodes.</description>
    </item>
    
    <item>
      <title>SpringCore</title>
      <link>https://jhlee1.github.io/2019/springcore/</link>
      <pubDate>Wed, 27 Feb 2019 23:10:04 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/springcore/</guid>
      <description>Spring Core 1. Spring 특징  엔터프라이즈급 어플리케이션을 구축할 수 있는 가벼운 솔루션이자, One-Stop-Shop(모든 과정을 한꺼번에 해결) 모듈화  약 20개의 모듈로 구성 필요한 모듈만 가져다 사용  IoC Container 선언적 Transaction을 관리할 수 있다 MVC Framework 제공 AOP  2. Spring Core 모듈  AOP와 Instrumentation
 spring-AOP : AOP 얼라이언스(Alliance)와 호환되는 방법으로 AOP를 지원 spring-aspects : AspectJ와의 통합을 제공 spring-instrument : instrumentation을 지원하는 클래스와 특정 WAS에서 사용하는 클래스로 더 구현체를 제공 BCI(Byte Code Instrumentations) - 런타임이나 로드(Load) 때 클래스의 바이트 코드에 변경을 가하는 방법  Messaging</description>
    </item>
    
    <item>
      <title>JavascriptObject</title>
      <link>https://jhlee1.github.io/2019/javascriptobject/</link>
      <pubDate>Wed, 27 Feb 2019 22:19:33 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/javascriptobject/</guid>
      <description>Javascript Object 1. 객체  key, value의 자료구조 {}로 자료를 표현하며, JSON형식이랑 같다.  2. 선언 var obj = {name: &amp;quot;John Doe&amp;quot;, age: 20, addition: [{name: &amp;quot;another one&amp;quot;, age: 99}]} console.log(obj.name); // John Doe console.log(obj[&amp;quot;name&amp;quot;]); // John Doe console.log(obj[name]); // Error : name이라는 변수를 찾기 때문에 console.log(obj.addition[0].name); // another one  3. 객체 탐색  For-in loop
 for-in은 key값을 탐색하기 위한 것이므로 Array(배열)가 아니라 Object(객체)에 사용한다
var obj = {name: &amp;quot;John Doe&amp;quot;, age: 20, addition: [{name: &amp;quot;another one&amp;quot;, age: 99}]} for(key in obj) { console.</description>
    </item>
    
    <item>
      <title>JavascriptArray</title>
      <link>https://jhlee1.github.io/2019/javascriptarray/</link>
      <pubDate>Wed, 27 Feb 2019 21:58:12 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/javascriptarray/</guid>
      <description>Javascript Array 1. 배열 선언 var arr = []; var arr = [1, 2, 3, &amp;quot;hello&amp;quot;, null, true, [[{1:0}]]]; console.log(arr.length); // 7   new Array()로 선언할 수 도 있지만 대부분 []을 사용  2. 원소 추가  index를 이용한 추가
var arr = [4]; arr[1000] = 3; console.log(a.length); // 1001 console.log(arr[500]); // undefined  push를 이용한 추가
var arr = [4]; arr.push(5); console.log(arr.length); // 2   3. 기타 유용한 Method [1,2,3,4].</description>
    </item>
    
    <item>
      <title>RESTAPI</title>
      <link>https://jhlee1.github.io/2019/restapi/</link>
      <pubDate>Tue, 26 Feb 2019 23:29:11 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/restapi/</guid>
      <description>REST API 1. REST API 조건  REST API라 불리기 위해선 아래의 조건들이 필요하다. 대부분의 조건은 만족하기 쉽지만 웹페이지가 아닌 API상에서 uniform interface의 하위 조건 중 일부를 만족하기 어려움 client-server stateless cache uniform interface layered system code-on-demand (optional) 위의 조건중 uniform interface의 조건  리소스가 URI로 식별되야 한다. 리소스를 생성,수정,추가하고자 할 때 HTTP메시지에 표현을 해서 전송해야 한다. 메시지는 스스로 설명할 수 있어야 한다. (Self-descriptive message) 애플리케이션의 상태는 Hyperlink를 이용해 전이되어야 한다.</description>
    </item>
    
    <item>
      <title>JDBC</title>
      <link>https://jhlee1.github.io/2019/jdbcbasic/</link>
      <pubDate>Mon, 25 Feb 2019 01:05:17 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/jdbcbasic/</guid>
      <description>JDBC 1. 개념  Java를 이용한 Database 접속과 SQL 실행, 실행 결과로 얻어진 Data의 핸들링을 제공하는 방법과 절차에 관한 규약 Java 프로그램 내에서 SQL문을 실행하기 위한 Java API SQL과 Programming 언어의 통합 접근 중 한 형태 Java는 표준 인터페이스인 JDBC API를 제공 Database vendor 또는 기타 Third Party에서는 JDBC 인터페이스를 구현한 Driver를 제공  2. JDBC 드라이버 설치  Maven에 Dependency 추가
&amp;lt;depencency&amp;gt; &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;5.1.45&amp;lt;/version&amp;gt; &amp;lt;/dependency&amp;gt;   3.</description>
    </item>
    
    <item>
      <title>Maven</title>
      <link>https://jhlee1.github.io/2019/maven/</link>
      <pubDate>Sun, 24 Feb 2019 11:12:08 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/maven/</guid>
      <description>Maven 1. 기존 외부 Libray이용 방식의 문제점  직접 jar 파일을 받아서 /lib 속에 넣어줌  프로젝트가 복잡해질수록 사용하는 Library의 양이 많아지고 컴파일과 배포가 어려워짐 여러 사람이 함께 작업할 경우 관리가 어려움  Maven을 사용하면 를 추가해줌으로써 직접 다운로드 받거나 하는 것을 하지 않아도 라이브러리를 사용할 수 있다. Maven에 설정한 대로 모든 개발자가 일관된 방식으로 빌드 -&amp;gt; 빌드 방법에 대해 따로 가이드를 만들 필요 없음 Maven의 다양한 플러그인을 이용하여 많은 일들을 자동화  2.</description>
    </item>
    
    <item>
      <title>Week1_lec4</title>
      <link>https://jhlee1.github.io/2019/week1_lec4/</link>
      <pubDate>Sun, 24 Feb 2019 10:39:13 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/week1_lec4/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Week1_lec3</title>
      <link>https://jhlee1.github.io/2019/week1_lec3/</link>
      <pubDate>Sun, 24 Feb 2019 10:39:09 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/week1_lec3/</guid>
      <description></description>
    </item>
    
    <item>
      <title>마이크로서비스 vs. 모노리스</title>
      <link>https://jhlee1.github.io/2019/week1_lec2/</link>
      <pubDate>Sun, 24 Feb 2019 10:39:07 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/week1_lec2/</guid>
      <description>마이크로서비스 vs. 모노리스 1. 개념  하나의 어플리케이션을 여러개의 서비스 집합으로 구성하는 것 Service Oriented Architecture의 연장선  2. SOA VS. MSA     MSA SOA     공통점 서비스 중심 설계 지향    Ownership 하나의 독립된 팀에서 개발과 관리 여러 팀의 협업(서비스 공유를 위한 미들웨어)   Size SOA 대비 작음 MSA대비 큼   Share API로 공유 UDDI로 공유   Communication Restful API WSDL, SOAP 통신   Storage 서비스 상 별도의 저장소를 두고 인터페이스를 통한 데이터 캡슐화를 지향 -&amp;gt; 쉬운 분리 및 대체 가능 서비스상 저장소를 분리하지 않음 -&amp;gt; 통합 저장소 사용 시 서비스 분리가 어렵다.</description>
    </item>
    
    <item>
      <title>Biz 민첩성과 아키텍처 요건</title>
      <link>https://jhlee1.github.io/2019/week1_lec1/</link>
      <pubDate>Sun, 24 Feb 2019 09:49:59 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/week1_lec1/</guid>
      <description>Biz 민첩성과 아키텍처 요건 1. 11.6초  Amazon이 Application을 배포하는 주기 일반 온라인 기업 서비스 기획 -&amp;gt; 서비스 지원용 어플리케이션 개발 -&amp;gt; (개선 사항 발생) -&amp;gt; 수정 후 배포 vs. 국내 쇼핑몰 배포 주기 - 3일 최근 빠른 비지니스의 변화로 빠르게 대응할 능력이 필요함  2. 개발 문화의 변화 (DevOps)  &amp;ldquo;The traditional model is that you take your software to the wall that separates development and operations, and throw it over and then forget about it.</description>
    </item>
    
    <item>
      <title>SQL Data Definition Language</title>
      <link>https://jhlee1.github.io/2019/sql_ddl/</link>
      <pubDate>Sun, 17 Feb 2019 00:44:19 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/sql_ddl/</guid>
      <description>DDL(Data Definition Language) 1. 정의  DB의 schema를 생성, 변경 제거  2. MySQL Data type  Check this link (https://dev.mysql.com/doc/refman/8.0/en/data-type-overview.html). I will summarize later  3. Create table  기본형
 CREATE TABLE tableName( field1 type [NULL | NOT NULL][DEFAULT][AUTO_INCREMENT] field2 type [NULL | NOT NULL][DEFAULT][AUTO_INCREMENT] field3 type [NULL | NOT NULL][DEFAULT][AUTO_INCREMENT] &amp;hellip;&amp;hellip;&amp;hellip;&amp;hellip; PRIMARY KEY(fieldName)  );
 NULL, NOT NULL로 필드에 빈 값 허용 여부 결정
 DEFAULT - 입력 값이 없는 경우 초기값 결정</description>
    </item>
    
    <item>
      <title>SQL(Data Manipulation Language)</title>
      <link>https://jhlee1.github.io/2019/sql_dml/</link>
      <pubDate>Sun, 17 Feb 2019 00:35:56 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/sql_dml/</guid>
      <description>DML(Data Manipulation Language) 1. SELECT  기본형  SELECT(DISTINCT) column (ALIAS) FROM table;  SELECT - 찾는 데이터(Column)을 나열 DISTINCT - 중복행 제거 ALIAS - 나타날 Column에 대한 다른 이름 부여 FROM - 선택한 Column이 있는 테이블을 명시
 ex) 전체 데이터 검색
 SELECT * FROM DEPARTMANT;
+--------+------------+----------+ | deptno | name | location | +--------+------------+----------+ | 10 | ACCOUNTING | NEW YORK | | 20 | RESEARCH | DALLAS | | 30 | SALES | CHICAGO | | 40 | OPERATIONS | BOSTON | +--------+------------+----------+ 4 rows in set (0.</description>
    </item>
    
    <item>
      <title>SQL Basic</title>
      <link>https://jhlee1.github.io/2019/sqlbasic/</link>
      <pubDate>Sat, 16 Feb 2019 21:45:07 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/sqlbasic/</guid>
      <description>1. SQL이란  SQL은 데이터를 쉽게 검색하고 추가, 삭제, 수정 같은 조작을 할 수 있도록 만들어진 언어 RDBMS에서 데이터를 조작, 쿼리하는 표준 수단 키워드는 대소문자를 구분하지 않음 (아래의 쿼리는 모두 같다)  mysql&amp;gt; SELECT VERSION(), CURRENT_DATE; mysql&amp;gt; select version(), current_date; mysql&amp;gt; SeLeCT vErsiOn(), CUrrENT_DATE;  QUERY를 계산식으로 쓸 수 있다.
 mysql&amp;gt; SELECT SIN(PI() / 4), (4+1) * 5;
+--------------------+-----------+ | SIN(PI() / 4) | (4+1) * 5 | +--------------------+-----------+ | 0.</description>
    </item>
    
    <item>
      <title>Install &amp; Set up My SQL</title>
      <link>https://jhlee1.github.io/2019/setupmysql/</link>
      <pubDate>Sat, 16 Feb 2019 21:12:24 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/setupmysql/</guid>
      <description>Set up MySQL Community Server in windows 1. 다운로드  https://www.mysql.com/downloads/ 여기서 Community Server의 다운로드 중 mysql-installer-community-X.0.XX.0.msi 받기
 web-community과 community 파일의 차이는 설치중에 파일을 받아서 설치하는 것 (인터넷 연결 필요)과 이미 설치파일에 들어있는 파일을 설치하는 것 (인터넷 연결 불필요). 따라서 설치 파일의 용량이 차이남
  2. 설치  msi파일을 실행 후 SetUp Type을 Developer Default로 설치 root 비밀번호만 정하고 Next 누르면됨 윈도우가 켜질 때 실행시키려면 Windows Service 설정에서 시작시 켜지도록 설정해놓으면 됨 환경변수 설정 - C:Program Files\MySQL\MySQL Server X.</description>
    </item>
    
    <item>
      <title>Database</title>
      <link>https://jhlee1.github.io/2019/database/</link>
      <pubDate>Fri, 15 Feb 2019 01:31:19 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/database/</guid>
      <description>Database와 DBMS(DataBase Management System) 1. 기본 개념  데이터의 집합(a Set of Data) 여러 응용 시스템(프로그램)들의 통합된 정보들을 저장하여 운영할 수 있는 공용(share) data의 집합 효율적으로 저장, 검색, 갱신할 수 있도록 데이터 집합들끼리 연관시키고 조직화되어야 한다.  2. 특성  실시간 접근성(Real-time Accessability)  사용자의 요구를 즉시 처리  계속적인 변화(Continuous Evolution)  정확한 값을 유지하려고 삽입, 삭제, 수정 작업 등을 이용해 데이터를 지속적으로 갱신  동시 공유성(Concurrent Sharing)  사용자마다 다른 목적으로 사용하므로 동시에 여러 사람이 동일한 데이터에 접근, 이용  내용 참조(Content Reference)  저장한 data의 record의 위치나 주소가 아닌 사용자가 요구하는 data의 내용, 즉 data 값에 따라 참조(reference)할 수 있어야 한다.</description>
    </item>
    
    <item>
      <title>JspBasic</title>
      <link>https://jhlee1.github.io/2019/jspbasic/</link>
      <pubDate>Wed, 06 Feb 2019 02:51:19 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/jspbasic/</guid>
      <description>JSP(Java Server Page)  모든 JSP는 Servlet으로 변경되어 작동한다. -&amp;gt; Servlet과 같은 LifeCycle을 가짐 &amp;lt;%@를 지시자라고 한다. &amp;lt;%@ page는 페이지 지시자라고 한다. JSP를 작성할 때 Servlet으로 어떻게 변경될까에 대해 생각하면서 하자 1 ~ 10까지 출력하는 예제   sum10.jsp &amp;lt;%@ page language=&amp;quot;java&amp;quot; contentType=&amp;quot;text/html; charset=UTF-8&amp;quot; pageEncoding=&amp;quot;UTF-8&amp;quot; %&amp;gt; &amp;lt;!DOCTYPE html PUBLIC &amp;quot;-//W3C//DTD HTML 4.01 Transitional//EN&amp;quot; &amp;quot;http://www.w3.org/TR/html4/loose.dtd&amp;quot;&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot; content=&amp;quot;text/html; charset=UTF-8&amp;quot;&amp;gt; &amp;lt;title&amp;gt;Insert title here&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;% int total = 0; for(int i = 1; i &amp;lt;= 10; i++) { total = total + i; } %&amp;gt; 1부터 10까지의 합: &amp;lt;%= total %&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt;   JSP의 LifeCycle</description>
    </item>
    
    <item>
      <title>JavascriptBasic</title>
      <link>https://jhlee1.github.io/2019/javascriptbasic/</link>
      <pubDate>Thu, 31 Jan 2019 22:35:29 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/javascriptbasic/</guid>
      <description>Javascript Hoisitng 함수는 실행되기 전 함수 안의 필요한 변수값들을 미리 다 모아서 선언  ex1)
function outer() { var result = inner; console.log(result) //result: undefined error var inner = function () { return &amp;quot;inner value&amp;quot;; } }  inner의 내부값이 assign되기 전으로 처리되어 에러 발생.
실제 처리된 결과:
function outer() { var result; var inner; console.log(result); inner = function () { return &amp;quot;inner value&amp;quot;; } }  ex2)
function outer() { var result = inner(); console.</description>
    </item>
    
    <item>
      <title>ServletBasic</title>
      <link>https://jhlee1.github.io/2019/servletbasic/</link>
      <pubDate>Wed, 30 Jan 2019 22:06:44 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/servletbasic/</guid>
      <description>Java Web Application의 폴더 구조
 WEB-INF가 반드시 존재해야됨 Servlet 3.0미만에선 web.xml이 필수적으로 있어야함. 이후 버전에는 annotation을 이용함  eclipse plugin
 eclipse의 workspace안에 .metadata/.plugins/org.eclipse.wst.server.core/tmp0을 열어보면 Tomcat과 비슷 구조이다. eclipse 내부적으로 Tomcat을 사용할 때 필요한 부분을 가져와서 쓴다고 생각하면 됨 wtpwebapps를 열어보면 여태까지 실습한 내용이 들어있음  Servlet이란?
 Java Web Application의 구성요소 중 동적 처리를 맡음 WAS에서 동작하는 Java class이다. HttpServlet class를 상속받아야한다 Servlet과 JSP로 최상의 결과를 얻으려면 조화롭게 사용해야 한다 (HTML은 JSP로, 복잡한 로직은 Servlet으로 처리)  Servlet 작동원리</description>
    </item>
    
    <item>
      <title>Links to Read</title>
      <link>https://jhlee1.github.io/2019/links-to-read/</link>
      <pubDate>Tue, 29 Jan 2019 23:55:46 +0900</pubDate>
      
      <guid>https://jhlee1.github.io/2019/links-to-read/</guid>
      <description>These are the links that I already / will read
 Hugo  https://github.com/Integerous/Integerous.github.io   </description>
    </item>
    
    <item>
      <title>Quick Sort</title>
      <link>https://jhlee1.github.io/1/quicksort/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jhlee1.github.io/1/quicksort/</guid>
      <description> Quick Sort public static void main(String[] args) { int[] arr = new int[]; quickSort(arr, 0, arr.length - 1) System.out.println(arr); } public static void quickSort(int[] arr, int left, int right) { if(left &amp;gt;= right) { return; } int pivot = (left + right) / 2; int index = partition(arr, left, right, pivot) quickSort(arr, left, index - 1); quickSort(arr, index, right); } public static int partition(int[] arr, int left, int right, int pivot) { while(left &amp;lt;= right) { while(arr[left] &amp;lt; pivot) { left++; } while(arr[right] &amp;gt; pivot) { right--; } if(left &amp;lt;= right) { swap(arr, left, right); left++; right--; } } return left }  </description>
    </item>
    
  </channel>
</rss>
